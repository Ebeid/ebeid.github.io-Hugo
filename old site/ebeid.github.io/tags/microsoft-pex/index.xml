<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Microsoft Pex on Ebeid ElSayed</title>
    <link>http://localhost:1313/tags/microsoft-pex/</link>
    <description>Recent content in Microsoft Pex on Ebeid ElSayed</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 13 Aug 2013 13:43:00 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/microsoft-pex/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to debug your Pex parameterized unit tests</title>
      <link>http://localhost:1313/blog/2013-08-13-how-to-debug-your-pex-parameterized.html/</link>
      <pubDate>Tue, 13 Aug 2013 13:43:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/2013-08-13-how-to-debug-your-pex-parameterized.html/</guid>
      <description>&lt;p&gt;We talked before about &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/getting-started-with-microsoft-pex.html&#34; title=&#34;Getting started with Microsoft Pex&#34;&gt;Microsoft&#xA;Pex&lt;/a&gt;,&#xA;and &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/why-pex-choose-these-inputs.html&#34; title=&#34;Why Pex Choose These Inputs&#34;&gt;how it choose the shown&#xA;inputs&lt;/a&gt;.&#xA;We then talked more about &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/microsoft-pex-understanding-assumptions.html&#34; title=&#34;Microsoft Pex: Understanding Assumptions, Assertions, and Test-Case Failures&#34;&gt;building blocks of parameterized unit&#xA;tests&lt;/a&gt;&#xA;and its&#xA;&lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/05/parameterized-test-patterns-using.html&#34; title=&#34;Parameterized Test Patterns using Microsoft Pex&#34;&gt;patterns&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;What we missed till now is how to debug your parameterized unit tests.&#xA;In order to debug your parameterized unit tests, do the following:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Go to Tools &amp;gt;&amp;gt; Options &amp;gt;&amp;gt; Pex &amp;gt;&amp;gt; Diagnostic.&lt;/li&gt;&#xA;&lt;li&gt;Change the &lt;em&gt;BreakOnStart&lt;/em&gt; option to &lt;em&gt;True.&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/img/0012.png&#34; alt=&#34;alt text&#34; title=&#34;Logo Title Text 1&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Convert Microsoft Pex path conditions from Z3 native format to SMT-LIB</title>
      <link>http://localhost:1313/blog/2013-08-01-convert-microsoft-pex-path-conditions.html/</link>
      <pubDate>Thu, 01 Aug 2013 16:24:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/2013-08-01-convert-microsoft-pex-path-conditions.html/</guid>
      <description>&lt;p&gt;We talked before about &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/07/get-path-conditions-from-microsoft-pex.html&#34; title=&#34;Get path conditions from Microsoft Pex&#34;&gt;getting the code path conditions from Microsoft&#xA;Pex&lt;/a&gt;&#xA;as in&#xA;&lt;a href=&#34;http://research.microsoft.com/en-us/um/redmond/projects/z3/old/index.html&#34; title=&#34;Z3 : An Efficient Theorem Prover&#34;&gt;Z3&lt;/a&gt;&#xA;native format(.z3 file).&lt;/p&gt;&#xA;&lt;p&gt;Sometimes you may need to convert from Z3 native format to&#xA;&lt;a href=&#34;http://www.smt-lib.org/&#34; title=&#34;SMT-LIB The Satisfiability Modulo Theories Library&#34;&gt;SMT-LIB&lt;/a&gt;&#xA;standard. You can do that using the &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/07/the-z3-constraint-solver-developer.html&#34; title=&#34;The Z3 Constraint Solver, a developer perspective&#34;&gt;Z3 C#&#xA;APIs&lt;/a&gt;.&#xA;The only trick here is: you have to use the Microsoft.Z3.dll that come&#xA;with your current Microsoft Pex installation (C:\Program&#xA;Files\Microsoft Pex\bin\Microsoft.Z3.dll).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Get path conditions from Microsoft Pex</title>
      <link>http://localhost:1313/blog/2013-07-24-get-path-conditions-from-microsoft-pex.html/</link>
      <pubDate>Wed, 24 Jul 2013 17:26:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/2013-07-24-get-path-conditions-from-microsoft-pex.html/</guid>
      <description>&lt;p&gt;We talked in a previous&#xA;&lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/why-pex-choose-these-inputs.html&#34; title=&#34;Why Pex Choose These Inputs&#34;&gt;post&lt;/a&gt;&#xA;about Microsoft Pex and how it choose values to explore your code&#xA;through symbolically executing it and getting all its paths. A code path&#xA;is the represented by all the conditions that have to be satisfied in&#xA;order to make the code execution go to this path. Your code conditional&#xA;statements will lead to different paths according to different input&#xA;values. Test cases generated by Pex represents the code behavior for&#xA;specific input values that lead to specific code path.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Parameterized Test Patterns using Microsoft Pex</title>
      <link>http://localhost:1313/blog/2013-05-02-parameterized-test-patterns-using.html/</link>
      <pubDate>Thu, 02 May 2013 16:08:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/2013-05-02-parameterized-test-patterns-using.html/</guid>
      <description>&lt;p&gt;We talked before about the difference between unit tests and&#xA;parameterized unit tests. In this post we will talk about common&#xA;patterns for writing good parameterized unit tests. Keep in mind that we&#xA;will use these tests with Microsoft Pex (as an automatic test input&#xA;generation tool) to get test inputs that trigger all the possible&#xA;scenarios of the code-under-test.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Before anything, let’s clarify what are the questions we want to&#xA;answer using the parameterized unit tests. There are  two core&#xA;questions:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Microsoft Pex: Understanding Assumptions, Assertions, and Test-Case Failures</title>
      <link>http://localhost:1313/blog/2013-04-29-microsoft-pex-understanding-assumptions.html/</link>
      <pubDate>Mon, 29 Apr 2013 15:00:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/2013-04-29-microsoft-pex-understanding-assumptions.html/</guid>
      <description>&lt;p&gt;In a previous post we started using Microsoft Pex and showed how it&#xA;helped exploring all possible code paths, and how that helped&#xA;discovering a defect in our program logic. In that example, even our&#xA;program logic is defective, all test cases succeeded. A test case fails&#xA;if there is an un-caught exception or a failed assertion.&lt;/p&gt;&#xA;&lt;p&gt;To see an example of a failed test case and how Pex could help in fixing&#xA;it, let’s add the following basic function to our code:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Getting started with Microsoft Code Digger</title>
      <link>http://localhost:1313/blog/2013-04-26-getting-started-with-microsoft-code.html/</link>
      <pubDate>Fri, 26 Apr 2013 03:00:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/2013-04-26-getting-started-with-microsoft-code.html/</guid>
      <description>&lt;p&gt;Microsoft Code Digger is Visual Studio 2012 extension that have been&#xA;released few days ago by RiSE team at Microsoft Research (the same team&#xA;who developed Pex). You can download the it from the Visual Studio&#xA;Gallery&#xA;&lt;a href=&#34;http://visualstudiogallery.msdn.microsoft.com/fb5badda-4ea3-4314-a723-a1975cbdabb4&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Microsoft Code Digger uses the same engine that Pex uses, and the same&#xA;techniques under the hood (dynamic symbolic execution and constraint&#xA;solvers). The only constrain that Code Digger have is that it only works&#xA;on public .NET code in Portable Class Libraries.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Why Pex Choose These Inputs</title>
      <link>http://localhost:1313/blog/2013-04-25-why-pex-choose-these-inputs.html/</link>
      <pubDate>Thu, 25 Apr 2013 03:00:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/2013-04-25-why-pex-choose-these-inputs.html/</guid>
      <description>&lt;p&gt;In the example we gave in the previous post, it may seem that Pex chose&#xA;random numbers as inputs for the Triang() method but it is not. But also&#xA;its not all possible values for the inputs.&lt;/p&gt;&#xA;&lt;p&gt;Actually, Pex generates test inputs by analyzing your program code, so&#xA;it is called whitebox test generation (as opposed to blackbox test&#xA;generation). For every statement in the code, Pex will eventually try to&#xA;create a test input that will reach that statement. Pex will do a case&#xA;analysis for every conditional branch in the code—for example, if&#xA;statements, assertions, and all operations that can throw exceptions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Getting started with Microsoft Pex</title>
      <link>http://localhost:1313/blog/2013-04-24-getting-started-with-microsoft-pex.html/</link>
      <pubDate>Wed, 24 Apr 2013 03:06:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/2013-04-24-getting-started-with-microsoft-pex.html/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://research.microsoft.com/en-us/projects/pex/&#34;&gt;Microsoft Pex&lt;/a&gt; is a&#xA;&lt;a href=&#34;http://research.microsoft.com/pubs/81193/fulltext.pdf&#34;&gt;white box test generation for&#xA;.NET&lt;/a&gt; that came&#xA;out of Microsoft Research and have been successfully integrated into&#xA;Visual Studio 2010. It have been a result of collaborative work between&#xA;Microsoft Research and the &lt;a href=&#34;https://sites.google.com/site/asergrp/&#34;&gt;Automated Software Engineering Research&#xA;Group&lt;/a&gt; at &lt;a href=&#34;http://www.ncsu.edu/&#34;&gt;North Carolina State&#xA;University&lt;/a&gt; led by  &lt;a href=&#34;http://www.csc.ncsu.edu/faculty/xie/&#34;&gt;Dr. Tao&#xA;Xie&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;You can download and install Microsoft Pex for Visual Studio 2010 from&#xA;&lt;a href=&#34;http://research.microsoft.com/en-us/projects/pex/downloads.aspx&#34;&gt;here&lt;/a&gt;.&#xA;We have talked in a previous&#xA;&lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/unit-tests-vs-parameterized-unit-tests.html&#34;&gt;post&lt;/a&gt;&#xA;about parameterized unit tests and the possibilities it brings. In this&#xA;post and the following we will explore Microsoft Pex and how it can help&#xA;you in understanding the input/output behavior of your code, finding&#xA;inputs that cause the code-under-test to crash, and exploring&#xA;parameterized unit tests to check whether your code implements the&#xA;desired functionality for all inputs.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unit Tests vs Parametrized Unit Tests</title>
      <link>http://localhost:1313/blog/2013-04-22-unit-tests-vs-parameterized-unit-tests.html/</link>
      <pubDate>Mon, 22 Apr 2013 17:17:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/2013-04-22-unit-tests-vs-parameterized-unit-tests.html/</guid>
      <description>&lt;h3 id=&#34;unit-tests&#34;&gt;Unit Tests&lt;/h3&gt;&#xA;&lt;p&gt;Using the conventions of NUnit unit tests as test methods contained in&#xA;test classes. A parameterless method decorated with a custom attribute&#xA;like [TestMethod] is a test method. Usually, each unit test explores a&#xA;particular aspect of the behavior of the class-under-test.&lt;/p&gt;&#xA;&lt;p&gt;Here is a unit test written in C# that adds an element to a .NET&#xA;ArrayList instance. The test first creates a new array list, where the&#xA;parameter to the constructor is the initial capacity, then adds a new&#xA;object to the array list, and finally checks that the addition was&#xA;correctly performed by verifying that a subsequent index lookup&#xA;operation returns the new object.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
